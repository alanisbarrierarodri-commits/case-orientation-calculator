<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>SSTK Case Orientation Calculator</title>
<style>
  :root {
    --walmart-blue: #0071ce;
    --walmart-yellow: #ffc220;
    --light-gray: #f5f5f5;
  }
  body { font-family: Arial, sans-serif; margin: 0; background: var(--light-gray); }
  header { background: var(--walmart-blue); color: white; padding: 15px; text-align: center; font-size: 1.4em; font-weight: bold; }
  .container { background: white; max-width: 640px; margin: 20px auto; padding: 20px; border-radius: 12px; box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1); }
  .page { display: none; }
  label { font-weight: bold; display: block; margin-top: 10px; }
  input, select { width: 100%; padding: 10px; margin: 5px 0 12px; border: 1px solid #ccc; border-radius: 8px; font-size: 1em; }
  button {
    padding: 10px 16px; margin: 8px 4px 0 0;
    background: var(--walmart-yellow); color: black; font-weight: bold;
    border: none; border-radius: 8px; font-size: 1em; transition: background 0.2s;
  }
  button:hover { background: #e6ac00; cursor: pointer; }
  .results-container { margin-top: 10px; display: flex; flex-direction: column; gap: 20px; max-height: 500px; overflow-y: auto; padding-right: 8px; }
  .result-card { border: 2px solid var(--walmart-blue); border-radius: 12px; box-shadow: 0 2px 6px rgba(0,0,0,0.15); padding: 15px; background: #f8fbff; }
  .result-header { font-size: 1.1em; font-weight: bold; color: white; background: var(--walmart-blue); padding: 6px 10px; border-radius: 8px; margin-bottom: 8px; }
  .result-metrics span { display: inline-block; margin-right: 15px; font-weight: bold; color: #333; }
  .result-metrics .highlight { color: var(--walmart-yellow); }
  canvas { display:block; max-width:100%; height:auto; margin-top:10px; border:1px solid #ccc; border-radius:6px; background:#e0e0e0; }
</style>
</head>
<body>
<header>SSTK Case Orientation Calculator</header>
<div class="container">

  <!-- PAGE 1 -->
  <div class="page" id="page-1" style="display:block;">
    <label for="dcNumber">DC:</label>
    <select id="dcNumber">
      <option value="7035">7035</option>
    </select>

    <label for="itemNumber">Item #:</label>
    <input type="text" id="itemNumber">
    <div style="text-align: center; margin: 10px 0;">
      <img src="https://github.com/alanisbarrierarodri-commits/case-orientation-calculator/blob/main/item.png?raw=true"
           alt="Item Image" style="max-width:100%; border-radius:8px;">
    </div>
    <button onclick="nextPage()">Next</button>
  </div>

  <!-- PAGE 2 -->
  <div class="page" id="page-2">
    <div style="margin: 15px 0; padding: 10px; background:#fff3cd; border-left:5px solid #ffc107;">
      <strong>Before measuring:</strong><br>
      • Round up half inches.<br>
      • Measure as case sits on pallet.<br>
      • If case has <strong>upright arrows</strong>, measure upright.
    </div>
    <div style="text-align: center; margin: 10px 0;">
      <img src="https://github.com/alanisbarrierarodri-commits/case-orientation-calculator/blob/main/measurement.png?raw=true"
           alt="Measurement Guide" style="max-width:100%; border-radius:8px;">
    </div>
    <div style="text-align: center; margin: 10px 0;">
      <img src="https://github.com/alanisbarrierarodri-commits/case-orientation-calculator/blob/main/upright.jpg?raw=true"
           alt="Upright Guide" style="max-width:100%; border-radius:8px;">
    </div>
    <label for="height">Height (inches):</label>
    <input type="number" id="height" step="0.01">
    <label for="length">Length (inches):</label>
    <small>Longest side</small>
    <input type="number" id="length" step="0.01">
    <label for="width">Width (inches):</label>
    <small>Shortest side</small>
    <input type="number" id="width" step="0.01">
    <button onclick="prevPage()">Previous</button>
    <button onclick="nextPage()">Next</button>
  </div>

  <!-- PAGE 3 -->
  <div class="page" id="page-3">
    <label>Select Slot Sizes (choose one or more):</label>
    <div id="slot-options">
      <label><input type="checkbox" value="30"> 30"</label><br>
      <label><input type="checkbox" value="40"> 40"</label><br>
      <label><input type="checkbox" value="50"> 50"</label><br>
      <label><input type="checkbox" value="60"> 60"</label><br>
      <label><input type="checkbox" value="71"> 71"</label><br>
      <label><input type="checkbox" value="73"> 73"</label><br>
      <label><input type="checkbox" value="75"> 75"</label><br>
      <label><input type="checkbox" value="110"> 110"</label><br>
    </div>
    <button onclick="prevPage()">Previous</button>
    <button onclick="calculate()">Calculate</button>
  </div>

  <!-- PAGE 4 -->
  <div class="page" id="page-4">
    <div class="results-container" id="results"></div>
    <button id="sendQA" onclick="sendToQA()">Send to QA</button>
    <button onclick="prevPage()">Previous</button>
  </div>

</div>

<script>
/* ---------- Page Navigation ---------- */
let lastResults = [];
let currentPage = 1;
function showPage(n){document.querySelectorAll('.page').forEach((p,i)=>p.style.display=(i+1===n)?'block':'none');currentPage=n;}
function nextPage(){if(currentPage<4)showPage(currentPage+1);}
function prevPage(){if(currentPage>1)showPage(currentPage-1);}

/* ---------- Packing Strategies with boundary checks ---------- */
function pushIfFits(placements, x, y, w, h, rot, palletL, palletW) {
    if (x + w <= palletL && y + h <= palletW) {
        placements.push({ x, y, w, h, rot });
        return true;
    }
    return false;
}

function packAllUnrotated(pl, pw, bl, bw) {
    if (bl <= 0 || bw <= 0) return [];
    const fitL = Math.floor(pl / bl);
    const fitW = Math.floor(pw / bw);
    const placements = [];
    for (let i = 0; i < fitL; i++) {
        for (let j = 0; j < fitW; j++) {
            pushIfFits(placements, i * bl, j * bw, bl, bw, 0, pl, pw);
        }
    }
    return placements;
}

function packAllRotated(pl, pw, bl, bw) {
    if (bw <= 0 || bl <= 0) return [];
    const fitL = Math.floor(pl / bw);
    const fitW = Math.floor(pw / bl);
    const placements = [];
    for (let i = 0; i < fitL; i++) {
        for (let j = 0; j < fitW; j++) {
            pushIfFits(placements, i * bw, j * bl, bw, bl, 1, pl, pw);
        }
    }
    return placements;
}


function packAlternatingRows(pl, pw, bl, bw) {
    const placements = [];
    let y = 0, toggle = false;
    while (y + Math.min(bl, bw) <= pw) {
        if (!toggle) {
            const fitL = Math.floor(pl / bl);
            for (let i = 0; i < fitL; i++) {
                pushIfFits(placements, i * bl, y, bl, bw, 0, pl, pw);
            }
            y += bw;
        } else {
            const fitL = Math.floor(pl / bw);
            for (let i = 0; i < fitL; i++) {
                pushIfFits(placements, i * bw, y, bw, bl, 1, pl, pw);
            }
            y += bl;
        }
        toggle = !toggle;
    }
    return placements;
}

function packLayer(pl, pw, bl, bw) {
    const placements = [];
    let freeRects = [{ x: 0, y: 0, w: pl, h: pw }];
    while (freeRects.length > 0) {
        let placed = false;
        for (let i = 0; i < freeRects.length; i++) {
            const r = freeRects[i];
            // Try unrotated
            if (bl <= r.w && bw <= r.h) {
                pushIfFits(placements, r.x, r.y, bl, bw, 0, pl, pw);
                const rightW = r.w - bl, bottomH = r.h - bw;
                freeRects.splice(i, 1);
                if (rightW > 0) freeRects.push({ x: r.x + bl, y: r.y, w: rightW, h: r.h });
                if (bottomH > 0) freeRects.push({ x: r.x, y: r.y + bw, w: r.w, h: bottomH });
                placed = true;
                break;
            }
            // Try rotated
            if (bw <= r.w && bl <= r.h) {
                pushIfFits(placements, r.x, r.y, bw, bl, 1, pl, pw);
                const rightW = r.w - bw, bottomH = r.h - bl;
                freeRects.splice(i, 1);
                if (rightW > 0) freeRects.push({ x: r.x + bw, y: r.y, w: rightW, h: r.h });
                if (bottomH > 0) freeRects.push({ x: r.x, y: r.y + bl, w: r.w, h: bottomH });
                placed = true;
                break;
            }
        }
        if (!placed) break;
    }
    return placements;
}


function chooseBestPacking(pl, pw, bl, bw) {
    if (bl <= 0 || bw <= 0 || pl <= 0 || pw <= 0) return { name: "Invalid", placements: [] };
    if (bl < bw) [bl, bw] = [bw, bl];

    const strategies = [
        { name: "All Unrotated", placements: packAllUnrotated(pl, pw, bl, bw) },
        { name: "All Rotated", placements: packAllRotated(pl, pw, bl, bw) },
        { name: "Alternating Rows", placements: packAlternatingRows(pl, pw, bl, bw) },
        { name: "Greedy Mixed", placements: packLayer(pl, pw, bl, bw) }
    ];

    const palletArea = pl * pw;
    strategies.forEach(s => {
        const usedArea = s.placements.reduce((sum, p) => sum + p.w * p.h, 0);
        s.cases = s.placements.length;
        s.whitespace = palletArea - usedArea;
    });

    // Filter out unrealistic results
    const filtered = strategies.filter(s => s.cases < 1000); // Arbitrary upper limit
    filtered.sort((a, b) => b.cases - a.cases || a.whitespace - b.whitespace);

    return filtered[0] || { name: "None Fit", placements: [] };
}


/* ---------- Calculate + Draw ---------- */
function calculate(){
    lastResults = [];
    const bl = parseFloat(document.getElementById('length').value);
    const bw = parseFloat(document.getElementById('width').value);
    const bh = parseFloat(document.getElementById('height').value);
    const palletL = 47, palletW = 40;
    const slots = [...document.querySelectorAll('#slot-options input:checked')].map(e=>parseInt(e.value));
    const results = document.getElementById('results');
    results.innerHTML = "";

    if([bl,bw,bh].some(v=>isNaN(v)||v<=0)){
        results.innerHTML="<div class='result-card'>Please enter valid positive numbers.</div>";
        showPage(4); return;
    }
    if(slots.length===0){
        results.innerHTML="<div class='result-card'>Please select at least one slot size.</div>";
        showPage(4); return;
    }

    slots.forEach(slot=>{
        const hi = Math.floor(slot/bh);
        if(hi<=0){
            results.innerHTML+=`<div class='result-card'><div class="result-header">Slot Size: ${slot}"</div><div>No layers fit (too tall).</div></div>`;
            return;
        }

        const best = chooseBestPacking(palletL,palletW,bl,bw);
        const ti = best.cases, total = ti*hi;
        lastResults.push({slotHeight:slot,TI:ti,HI:hi,Total:total,Strategy:best.name});

        const card = document.createElement('div');
        card.className="result-card";
        card.innerHTML=`<div class="result-header">Slot Size: ${slot}"</div>
        <div class="result-metrics">
            <span>TI (per layer): <span class="highlight">${ti}</span></span>
            <span>HI (layers): <span class="highlight">${hi}</span></span>
            <span>Total: <span class="highlight">${total}</span></span>
        </div>`;

        const canvas=document.createElement('canvas');
        canvas.width=400; canvas.height=360;
        card.appendChild(canvas);
        const ctx=canvas.getContext('2d');
        const scaleX = canvas.width/palletL;
        const scaleY = (canvas.height-40)/palletW;
        ctx.strokeStyle="#000"; ctx.lineWidth=2;
        ctx.strokeRect(0,0,palletL*scaleX,palletW*scaleY);

        best.placements.forEach(p=>{
            ctx.fillStyle=p.rot?'#0071ce':'#ffc220';
            ctx.fillRect(p.x*scaleX,p.y*scaleY,p.w*scaleX,p.h*scaleY);
            ctx.strokeStyle="#000";
            ctx.strokeRect(p.x*scaleX,p.y*scaleY,p.w*scaleX,p.h*scaleY);
        });

        ctx.fillStyle="#000"; ctx.font="14px Arial";
        const bottomText='47" (Longest Side)';
        const bottomWidth = ctx.measureText(bottomText).width;
        ctx.fillText(bottomText,(canvas.width-bottomWidth)/2,canvas.height-5);

        const legendContainer=document.createElement('div');
        legendContainer.style.marginTop='10px'; legendContainer.style.display='flex';
        legendContainer.style.gap='20px'; legendContainer.style.alignItems='center';
        legendContainer.style.paddingTop='5px'; legendContainer.style.borderTop='1px solid #ccc';

        const unrotated=document.createElement('div');
        unrotated.style.display='flex'; unrotated.style.alignItems='center';
        unrotated.innerHTML=`<div style="width:20px;height:20px;background:#ffc220;margin-right:5px;border:1px solid #000;"></div>Unrotated`;
        legendContainer.appendChild(unrotated);

        const rotated=document.createElement('div');
        rotated.style.display='flex'; rotated.style.alignItems='center';
        rotated.innerHTML=`<div style="width:20px;height:20px;background:#0071ce;margin-right:5px;border:1px solid #000;"></div>Rotated`;
        legendContainer.appendChild(rotated);

        card.appendChild(legendContainer);
        results.appendChild(card);
    });

    showPage(4);
}

/* ---------- Send To QA ---------- */
async function sendToQA(){
    const payload={
        dcNumber:document.getElementById('dcNumber').value,
        itemNumber:document.getElementById('itemNumber').value,
        length:document.getElementById('length').value,
        width:document.getElementById('width').value,
        height:document.getElementById('height').value,
        slotResults:lastResults
    };
    try{
        const resp = await fetch('/api/submit',{
            method:'POST', headers:{'Content-Type':'application/json'}, body:JSON.stringify(payload)
        });
        const data = await resp.json();
        if(!resp.ok) throw new Error(data.error||'Error sending to QA');
        alert('✅ Sent to QA!');
    }catch(err){
        console.error(err);
        alert('❌ Failed to send to QA');
    }
}
</script>
</body>
</html>


